<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>To æ˜¥æ˜¥ - åœ£è¯å¿«ä¹</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: #050505;
      overflow: hidden;
      font-family: "Microsoft YaHei", sans-serif;
      touch-action: none;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    #input_video {
      display: none;
    }

    #ui-layer {
      position: absolute;
      bottom: 40px;
      width: 100%;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    .hint-box {
      display: inline-block;
      background: rgba(30, 30, 30, 0.6);
      backdrop-filter: blur(4px);
      padding: 12px 24px;
      border-radius: 30px;
      border: 1px solid rgba(255, 154, 158, 0.3);
      color: rgba(255, 200, 210, 0.9);
      font-size: 14px;
      box-shadow: 0 0 15px rgba(255, 154, 158, 0.2);
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff9a9e;
      text-align: center;
      font-size: 14px;
      z-index: 20;
      transition: opacity 0.5s;
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }
  </style>
</head>

<body>

  <div id="loading" class="loading">
    <div>æ­£åœ¨å”¤é†’æš´é£é›ª...</div>
    <div style="font-size:12px; opacity:0.7; margin-top:5px;">(è¯·æ±‚å¼€å¯æ‘„åƒå¤´ä»¥ä½“éªŒæ‰‹åŠ¿äº¤äº’)</div>
  </div>
  <video id="input_video"></video>

  <div id="ui-layer">
    <div class="hint-box" id="hint-text">æ­£åœ¨å¯åŠ¨...</div>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hintText = document.getElementById('hint-text');
    const loadingDiv = document.getElementById('loading');

    // --- æ ¸å¿ƒé…ç½® ---
    let width, height;
    let isMobile = false;
    let focalLength = 700;

    // ç²’å­æ±  (å®é™…æ¸²æŸ“æ•°é‡åœ¨ resize ä¸­åŠ¨æ€å®šä¹‰)
    let particles = [];
    let bgParticles = [];

    // å½“å‰æ¿€æ´»çš„ç²’å­æ•°é‡ (å®‰å…¨é˜ˆå€¼)
    let activeParticleCount = 0; // ä¸»ä½“ç”»é¢ç²’å­æ•°
    let activeBgCount = 0;       // èƒŒæ™¯é›ªèŠ±æ•°

    const colors = {
      main: ['#ffffff', '#ffebf0', '#ffc2d1', '#ff9a9e', '#ffb7b2'],
      heart: '#ff2244',
      ring: '#ffcce6'
    };

    let currentScene = 0;
    const scenes = ['tree', 'love', 'name'];
    let isExploded = false;
    let rotationY = 0;
    let cameraActive = false;

    // --- åˆå§‹åŒ– ---
    function init() {
      resize();
      // ç›‘å¬çª—å£è°ƒæ•´
      window.addEventListener('resize', () => {
        resize();
        // å»¶è¿Ÿé‡ç»˜ï¼Œé˜²æ­¢åˆ‡æ¢è¿‡å¿«é—ªçƒ
        setTimeout(() => loadScene(currentScene), 200);
      });

      // 1. åˆå§‹åŒ–ç²’å­æ±  (æŒ‰ç”µè„‘ç«¯æœ€å¤§éœ€æ±‚åˆ›å»ºï¼Œé¿å…ä¸­é€” new å¯¹è±¡é€ æˆå¡é¡¿)
      // ä¸»ä½“æ± ï¼š6000ä¸ªè¶³å¤Ÿé«˜æ¸…
      for (let i = 0; i < 6000; i++) {
        particles.push(new Particle(true));
      }
      // èƒŒæ™¯æ± ï¼š3000ä¸ªè¶³å¤Ÿæš´é£é›ª
      for (let i = 0; i < 35000; i++) {
        bgParticles.push(new Particle(false));
      }

      loadScene(0);
      loop();
      startCamera();
    }

    // --- å…³é”®ï¼šå®‰å…¨æ•°å€¼æ§åˆ¶ ---
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;

      isMobile = width < 768;

      if (isMobile) {
        // ã€æ‰‹æœºç«¯å®‰å…¨é…ç½®ã€‘
        // æ‰‹æœº Canvas æ€§èƒ½æœ‰é™ï¼Œæ€»ç²’å­æ•°æ§åˆ¶åœ¨ 3500 ä»¥å†…æœ€ç¨³
        activeParticleCount = 2200; // ä¿è¯å›¾å½¢æ¸…æ™°
        activeBgCount = 1000;       // 1000ç‰‡é›ªèŠ±åœ¨æ‰‹æœºå±ä¸Šå·²ç»å¾ˆå¯†äº†
        focalLength = 500;
      } else {
        // ã€ç”µè„‘ç«¯é«˜æ¸…é…ç½®ã€‘
        activeParticleCount = 5500; // æé«˜æ¸…æ™°åº¦
        activeBgCount = 15000;       // æ¼«å¤©å¤§é›ª
        focalLength = 800;
      }
    }

    // --- ç²’å­ç±» ---
    class Particle {
      constructor(isMain) {
        this.isMain = isMain;
        this.reset();
        this.color = '#FFF6F6';
        this.size = isMain ? Math.random() * 2 + 0.5 : Math.random() * 1.5;
        this.ease = 0.04 + Math.random() * 0.05;
        this.alpha = Math.random();
        this.fadeSpeed = 0.01 + Math.random() * 0.02;

        if (!isMain) {
          this.initSnow();
        }
      }

      reset() {
        this.x = (Math.random() - 0.5) * width;
        this.y = (Math.random() - 0.5) * height;
        this.z = (Math.random() - 0.5) * 1000;
        this.tx = 0; this.ty = 0; this.tz = 0;
        this.ex = 0; this.ey = 0; this.ez = 0;
      }

      // åˆå§‹åŒ–æš´é£é›ªå‚æ•°
      initSnow() {
        // éšæœºåˆ†å¸ƒåœ¨å±å¹•å†…å¤–
        this.x = (Math.random() - 0.5) * width * 1.5;
        this.y = (Math.random() - 0.5) * height * 1.5;
        this.z = (Math.random() - 0.5) * 1500;

        // æš´é£é›ªé€Ÿåº¦ï¼šä¸‹è½å¿«ï¼Œä¸”æœ‰æ¨ªå‘é£
        this.fallSpeed = 2 + Math.random() * 3; // ä¸‹è½é€Ÿåº¦ (2-5)
        this.windSpeed = 1 + Math.random() * 1.5; // å‘å³å¹çš„é£ (1-2.5)

        this.color = '#e0f7fa'; // å¾®å¾®åè“çš„é›ªç™½è‰²
      }

      update() {
        let targetX, targetY, targetZ;

        if (this.isMain) {
          // --- ä¸»ä½“é€»è¾‘ ---
          if (isExploded) {
            targetX = this.ex; targetY = this.ey; targetZ = this.ez;
          } else {
            targetX = this.tx; targetY = this.ty; targetZ = this.tz;
          }
          // å¹³æ»‘è¿åŠ¨
          this.x += (targetX - this.x) * this.ease;
          this.y += (targetY - this.y) * this.ease;
          this.z += (targetZ - this.z) * this.ease;

        } else {
          // --- æš´é£é›ªé€»è¾‘ ---
          this.y += this.fallSpeed; // å‚ç›´ä¸‹è½
          this.x += this.windSpeed; // æ°´å¹³é£å¹

          // è¾¹ç•Œå¾ªç¯ï¼šå¦‚æœæ‰å‡ºå±å¹•åº•éƒ¨ï¼Œæˆ–è€…é£˜å‡ºå±å¹•å³ä¾§ï¼Œé‡ç½®åˆ°é¡¶éƒ¨æˆ–å·¦ä¾§
          if (this.y > height / 2 + 100) {
            this.y = -height / 2 - 100;
            this.x = (Math.random() - 0.5) * width * 1.5; // éšæœºX
          }
          if (this.x > width / 2 + 100) {
            this.x = -width / 2 - 100;
            this.y = (Math.random() - 0.5) * height * 1.5;
          }

          // é›ªèŠ±ä¸éœ€è¦ Lerp ç¼“åŠ¨ï¼Œç›´æ¥æ”¹å˜åæ ‡
        }

        // é—ªçƒ/é€æ˜åº¦å˜åŒ–
        this.alpha += this.fadeSpeed;
        if (this.alpha > 1 || this.alpha < 0.2) this.fadeSpeed = -this.fadeSpeed;
      }

      draw() {
        let rx = this.x, ry = this.y, rz = this.z;

        if (this.isMain) {
          // åªæœ‰ä¸»ä½“å‚ä¸æ—‹è½¬
          const cos = Math.cos(rotationY);
          const sin = Math.sin(rotationY);
          rx = this.x * cos - this.z * sin;
          rz = this.z * cos + this.x * sin;
        }
        // é›ªèŠ±ä¸å‚ä¸æ•´ä½“æ—‹è½¬ï¼Œä¿æŒèƒŒæ™¯å›ºå®šï¼Œé¿å…çœ©æ™•æ„Ÿ

        const scale = focalLength / (focalLength + rz);
        const x2d = width / 2 + rx * scale;
        const y2d = height / 2 + ry * scale;
        const s2d = this.size * scale;

        if (rz > -focalLength && scale > 0) {
          ctx.fillStyle = this.color;
          ctx.globalAlpha = Math.max(0, Math.min(1, this.alpha));
          ctx.beginPath();
          ctx.arc(x2d, y2d, s2d, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      explode() {
        const range = isMobile ? 800 : 1500;
        this.ex = (Math.random() - 0.5) * range;
        this.ey = (Math.random() - 0.5) * range;
        this.ez = (Math.random() - 0.5) * range;
      }
    }

    // --- æ¸²æŸ“å¾ªç¯ (åªæ¸²æŸ“ active æ•°é‡) ---
    function loop() {
      ctx.clearRect(0, 0, width, height);
      ctx.globalCompositeOperation = 'lighter';

      rotationY += 0.003;

      // 1. æ¸²æŸ“æš´é£é›ª (åªå¾ªç¯ activeBgCount æ¬¡)
      for (let i = 0; i < activeBgCount; i++) {
        bgParticles[i].update();
        bgParticles[i].draw();
      }

      // 2. æ¸²æŸ“ä¸»ä½“ (åªå¾ªç¯ activeParticleCount æ¬¡)
      for (let i = 0; i < particles.length; i++) {
        if (particles[i].isMain && i < activeParticleCount) {
          particles[i].update();
          particles[i].draw();
        }
      }

      requestAnimationFrame(loop);
    }

    // --- å›¾å½¢ç”Ÿæˆç®—æ³• ---

    function getTreeCoords() {
      const coords = [];
      const minDim = Math.min(width, height);
      const h = minDim * 0.8;
      const maxR = minDim * 0.35;

      // ä¸»ä½“
      const spiralCount = activeParticleCount * 0.75;
      for (let i = 0; i < spiralCount; i++) {
        const p = i / spiralCount;
        const y = (p - 0.5) * h;
        const r = p * maxR;
        const angle = p * Math.PI * 25;
        const finalR = r * (0.4 + 0.6 * Math.random());

        coords.push({
          x: Math.cos(angle) * finalR,
          y: y + h * 0.1,
          z: Math.sin(angle) * finalR,
          color: colors.main[Math.floor(Math.random() * colors.main.length)]
        });
      }

      // çˆ±å¿ƒ
      const heartCount = activeParticleCount * 0.1;
      const topY = -h / 2;
      for (let i = 0; i < heartCount; i++) {
        const t = Math.random() * Math.PI * 2;
        const hk = isMobile ? 0.3 : 0.5;
        const hx = 16 * Math.pow(Math.sin(t), 3);
        const hy = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

        coords.push({
          x: hx * hk * 1.5,
          y: topY + hy * hk * 1.5 + h * 0.1 - 20,
          z: (Math.random() - 0.5) * 10,
          color: colors.heart
        });
      }

      // å…‰ç¯
      const ringCount = activeParticleCount * 0.15;
      for (let i = 0; i < ringCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const r = maxR * (0.8 + Math.random() * 0.5);
        coords.push({
          x: Math.cos(angle) * r,
          y: h / 2 + h * 0.1,
          z: Math.sin(angle) * r,
          color: colors.ring
        });
      }
      return coords;
    }

    function getTextCoords(text) {
      const offCanvas = document.createElement('canvas');
      const offCtx = offCanvas.getContext('2d');
      offCanvas.width = width;
      offCanvas.height = height;

      let baseSize = width / 5;
      if (text.length > 4) baseSize = width / (text.length + 1);
      const fontSize = Math.min(baseSize, 180);

      offCtx.font = `bold ${fontSize}px "Microsoft YaHei", Arial`;
      offCtx.fillStyle = '#fff';
      offCtx.textAlign = 'center';
      offCtx.textBaseline = 'middle';
      offCtx.fillText(text, width / 2, height / 2);

      const data = offCtx.getImageData(0, 0, width, height).data;
      const coords = [];
      const gap = isMobile ? 4 : 5;

      for (let y = 0; y < height; y += gap) {
        for (let x = 0; x < width; x += gap) {
          if (data[(y * width + x) * 4 + 3] > 128) {
            const colorIndex = Math.floor(Math.random() * colors.main.length);
            coords.push({
              x: (x - width / 2) * 1.2,
              y: (y - height / 2) * 1.2,
              z: (Math.random() - 0.5) * 40,
              color: colors.main[colorIndex]
            });
          }
        }
      }
      return coords;
    }

    function loadScene(index) {
      let targets = [];
      const s = scenes[index];
      if (s === 'tree') targets = getTreeCoords();
      else if (s === 'love') targets = getTextCoords('I ğŸ’— U æ˜¥æ˜¥');
      else if (s === 'name') targets = getTextCoords('åœ£è¯å¿«ä¹');

      // ç²’å­åˆ†é…
      const minNeeded = Math.floor(activeParticleCount * 0.9);
      if (targets.length < minNeeded) {
        const len = targets.length;
        if (len > 0) {
          for (let i = len; i < minNeeded; i++) {
            const base = targets[i % len];
            targets.push({
              x: base.x + (Math.random() - 0.5) * 5,
              y: base.y + (Math.random() - 0.5) * 5,
              z: base.z,
              color: base.color
            });
          }
        }
      }

      const pIndices = Array.from({ length: particles.length }, (_, i) => i);
      pIndices.sort(() => Math.random() - 0.5);

      for (let i = 0; i < particles.length; i++) {
        const p = particles[pIndices[i]];
        if (i < activeParticleCount && i < targets.length) {
          p.tx = targets[i].x;
          p.ty = targets[i].y;
          p.tz = targets[i].z;
          p.color = targets[i].color;
          p.isMain = true;
          p.ease = Math.min(0.08, p.ease + 0.02);
        } else {
          p.isMain = false;
          p.tx = (Math.random() - 0.5) * width * 2;
          p.ty = (Math.random() - 0.5) * height * 2;
        }
      }
    }

    // --- æ‰‹åŠ¿äº¤äº’ ---
    function startCamera() {
      const videoElement = document.getElementById('input_video');
      const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults(onResults);

      const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 640, height: 480
      });

      camera.start()
        .then(() => {
          loadingDiv.classList.add('hidden');
          hintText.innerHTML = "ğŸ–ï¸ å¼ æ‰‹ï¼šé©±æ•£é£é›ª | âœŠ æ¡æ‹³ï¼šå‡èšæµªæ¼«";
          cameraActive = true;
        })
        .catch(err => {
          useClickMode();
        });
    }

    let lastActionTime = 0;

    function onResults(results) {
      if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) return;

      const lm = results.multiHandLandmarks[0];
      const d = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      const palmSize = d(lm[0], lm[9]);
      const tips = [8, 12, 16, 20];
      let tipAvg = 0;
      tips.forEach(i => tipAvg += d(lm[0], lm[i]));
      tipAvg /= 4;

      const ratio = tipAvg / palmSize;
      const now = Date.now();
      if (now - lastActionTime < 500) return;

      if (ratio > 1.3) {
        if (!isExploded) {
          isExploded = true;
          particles.forEach(p => { if (p.isMain) p.explode(); });
          hintText.innerText = "âœ¨ ç²’å­å·²æ•£å¼€... è¯·æ¡æ‹³èšæ‹¢";
          lastActionTime = now;
        }
      } else if (ratio < 1.0) {
        if (isExploded) {
          isExploded = false;
          currentScene = (currentScene + 1) % scenes.length;
          loadScene(currentScene);
          hintText.innerText = "â¤ï¸ ç”»é¢å·²èšæ‹¢... è¯·å¼ æ‰‹åˆ‡æ¢";
          lastActionTime = now;
        }
      }
    }

    function useClickMode() {
      loadingDiv.classList.add('hidden');
      hintText.innerHTML = "ç‚¹å‡»å±å¹•åˆ‡æ¢ç”»é¢ (æ‰‹åŠ¿æ¨¡å¼ä¸å¯ç”¨)";
      cameraActive = false;

      document.addEventListener('click', () => {
        const now = Date.now();
        if (now - lastActionTime < 600) return;
        if (isExploded) return;

        isExploded = true;
        particles.forEach(p => { if (p.isMain) p.explode(); });
        lastActionTime = now;

        setTimeout(() => {
          currentScene = (currentScene + 1) % scenes.length;
          loadScene(currentScene);
          isExploded = false;
        }, 1500);
      });
    }

    init();

  </script>
</body>

</html>